const isaData = [
  { instruction: "MOV RZ, RX", description: "Move integer register contents", classBinary: "01", classSpecOpcode: "00000", operands: "REG(out) REG(1) OPT(000)", example: "MOV R1, R2" },
  { instruction: "MOVF FZ, FX", description: "Move floating-point register contents", classBinary: "01", classSpecOpcode: "00000", operands: "REG_F(out) REG_F(1) OPT(001)", example: "MOVF F0, F1" },
  { instruction: "MOVL RX", description: "Move from link register to general purpose register", classBinary: "01", classSpecOpcode: "00000", operands: "REG(out) OPT(010)", example: "MOVL R0" },
  { instruction: "ADD RZ, RX, RY", description: "Add, updates CPSR reg bits", classBinary: "01", classSpecOpcode: "00001", operands: "REG(out) REG(1) REG(2)", example: "ADD R1, R2, R3" },
  { instruction: "SUB RZ, RX, RY", description: "Subtract, updates CPSR reg bits", classBinary: "01", classSpecOpcode: "00010", operands: "REG(out) REG(1) REG(2)", example: "SUB R1, R2, R3" },
  { instruction: "MULH RZ, RX, RY", description: "Signed multiply, stores high bits", classBinary: "01", classSpecOpcode: "00011", operands: "REG(out) REG(1) REG(2)", example: "MULH R0, R1, R2" },
  { instruction: "UMULH RZ, RX, RY", description: "Unsigned multiply, stores high bits", classBinary: "01", classSpecOpcode: "00100", operands: "REG(out) REG(1) REG(2)", example: "UMULH R0, R1, R2" },
  { instruction: "UCMP RX, RY", description: "Unsigned compare", classBinary: "01", classSpecOpcode: "00101", operands: "REG(1) REG(2) OPT(000)", example: "UCMP R0, R1" },
  { instruction: "CMP RX, RY", description: "Signed compare", classBinary: "01", classSpecOpcode: "00101", operands: "REG(1) REG(2) OPT(001)", example: "CMP R0, R1" },
  { instruction: "FCMP FX, FY", description: "Floating-point compare", classBinary: "01", classSpecOpcode: "00101", operands: "REG_F(1) REG_F(2) OPT(010)", example: "FCMP F0, F1" },
  { instruction: "AND RZ, RX, RY", description: "Bitwise AND", classBinary: "01", classSpecOpcode: "00110", operands: "REG(out) REG(1) REG(2)", example: "AND R0, R1, R2" },
  { instruction: "OR RZ, RX, RY", description: "Bitwise OR", classBinary: "01", classSpecOpcode: "00111", operands: "REG(out) REG(1) REG(2)", example: "OR R0, R1, R2" },
  { instruction: "NOR RZ, RX, RY", description: "Bitwise NOR", classBinary: "01", classSpecOpcode: "01000", operands: "REG(out) REG(1) REG(2)", example: "NOR R0, R1, R2" },
  { instruction: "NAND RZ, RX, RY", description: "Bitwise NAND", classBinary: "01", classSpecOpcode: "01001", operands: "REG(out) REG(1) REG(2)", example: "NAND R0, R1, R2" },
  { instruction: "XOR RZ, RX, RY", description: "Bitwise XOR", classBinary: "01", classSpecOpcode: "01010", operands: "REG(out) REG(1) REG(2)", example: "XOR R0, R1, R2" },
  { instruction: "XNOR RZ, RX, RY", description: "Bitwise XNOR", classBinary: "01", classSpecOpcode: "01011", operands: "REG(out) REG(1) REG(2)", example: "XNOR R0, R1, R2" },
  { instruction: "NOT RZ, RX", description: "Negate", classBinary: "01", classSpecOpcode: "01100", operands: "REG(out) REG(1)", example: "NOT R0, R1" },
  { instruction: "MULL RZ, RX, RY", description: "Signed multiply, stores low bits", classBinary: "01", classSpecOpcode: "01111", operands: "REG(out) REG(1) REG(2)", example: "MULL R0, R1, R2" },
  { instruction: "UMULL RZ, RX, RY", description: "Unsigned multiply, stores low bits", classBinary: "01", classSpecOpcode: "10000", operands: "REG(out) REG(1) REG(2)", example: "UMULL R0, R1, R2" },
  { instruction: "FADD FZ, FX, FY", description: "Floating-point addition", classBinary: "01", classSpecOpcode: "10001", operands: "REG_F(out) REG_F(1) REG_F(2)", example: "FADD F0, F1, F2" },
  { instruction: "FSUB FZ, FX, FY", description: "Floating-point subtraction", classBinary: "01", classSpecOpcode: "10010", operands: "REG_F(out) REG_F(1) REG_F(2)", example: "FSUB F0, F1, F2" },
  { instruction: "FMUL FZ, FX, FY", description: "Floating-point multiplication", classBinary: "01", classSpecOpcode: "10011", operands: "REG_F(out) REG_F(1) REG_F(2)", example: "FMUL F0, F1, F2" },
  { instruction: "FTOI RZ, FX", description: "Convert FP to Int", classBinary: "01", classSpecOpcode: "10110", operands: "REG(out) REG_F(1) OPT(000)", example: "FTOI R0, F0" },
  { instruction: "ITOF FZ, RX", description: "Convert Int to Float", classBinary: "01", classSpecOpcode: "10110", operands: "REG_F(out) REG(1) OPT(001)", example: "ITOF F0, R0" },
  { instruction: "LSR RZ, RX, RY", description: "Logical shift right", classBinary: "01", classSpecOpcode: "11000", operands: "REG(out) REG(1) REG(2)", example: "LSR R0, R1, R2" },
  { instruction: "LSL RZ, RX, RY", description: "Logical shift left", classBinary: "01", classSpecOpcode: "11001", operands: "REG(out) REG(1) REG(2)", example: "LSL R0, R1, R2" },
  { instruction: "ASR RZ, RX, RY", description: "Arithmetic shift right", classBinary: "01", classSpecOpcode: "11010", operands: "REG(out) REG(1) REG(2)", example: "ASR R0, R1, R2" },
  { instruction: "ASL RZ, RX, RY", description: "Arithmetic shift left", classBinary: "01", classSpecOpcode: "11011", operands: "REG(out) REG(1) REG(2)", example: "ASL R0, R1, R2" },
  { instruction: "ROR RZ, RX, RY", description: "Rotate right", classBinary: "01", classSpecOpcode: "11100", operands: "REG(out) REG(1) REG(2)", example: "ROR R0, R1, R2" },
  { instruction: "JALR RZ, RX", description: "Jump and Link with register", classBinary: "01", classSpecOpcode: "11101", operands: "REG(out) REG(1)", example: "JALR R0, R1" },

  { instruction: "LDR RZ, RX, IMM", description: "Load half-word (16-bit) with offset", classBinary: "00", classSpecOpcode: "00", operands: "REG(out) REG/OPT IMM", example: "LDR R1, R2, #4" },
  { instruction: "STR RZ, RX, IMM", description: "Store half-word (16-bit) with offset", classBinary: "00", classSpecOpcode: "01", operands: "REG(out) REG/OPT IMM", example: "STR R1, R2, #4" },
  { instruction: "ADDI RZ, RX, IMM", description: "Add immediate", classBinary: "00", classSpecOpcode: "10", operands: "REG(out) REG/OPT IMM", example: "ADDI R1, R2, #8" },
  { instruction: "SUBI RZ, RX, IMM", description: "Subtract immediate", classBinary: "00", classSpecOpcode: "11", operands: "REG(out) REG/OPT IMM", example: "SUBI R1, R2, #8" },

  { instruction: "B IMM", description: "Unconditional branch", classBinary: "10 (branch)", classSpecOpcode: "000", operands: "OPT IMM(offset)", example: "B label" },
  { instruction: "BEQ IMM", description: "Branch if equal (CPSR Z=1)", classBinary: "10 (branch)", classSpecOpcode: "001", operands: "OPT IMM(offset)", example: "BEQ label" },
  { instruction: "BNE IMM", description: "Branch if not equal (CPSR Z=0)", classBinary: "10 (branch)", classSpecOpcode: "010", operands: "OPT IMM(offset)", example: "BNE label" },
  { instruction: "BLE IMM", description: "Branch less or equal (CPSR N=1|Z=1)", classBinary: "10 (branch)", classSpecOpcode: "011", operands: "OPT IMM(offset)", example: "BLE label" },
  { instruction: "BGT IMM", description: "Branch greater or equal (CPSR N=0|Z=1)", classBinary: "10 (branch)", classSpecOpcode: "100", operands: "OPT IMM(offset)", example: "BGT label" },
  { instruction: "JAL IMM", description: "Jump and link with immediate", classBinary: "10 (branch)", classSpecOpcode: "101", operands: "OPT IMM(offset)", example: "JAL label" },
  { instruction: "RET", description: "Return (from link)", classBinary: "10 (branch)", classSpecOpcode: "110", operands: "--", example: "RET" },

  { instruction: "CMP RX, IMM", description: "Compare with immediate", classBinary: "10 (non-branch)", classSpecOpcode: "000 ", operands: "REG(1) IMM", example: "CMP R0, #5" },
  { instruction: "UCMP RX, IMM", description: "Unsigned compare with immediate", classBinary: "10(non-branch)", classSpecOpcode: "001 ", operands: "REG(1) IMM", example: "UCMP R0, #5" },
  { instruction: "MOVI RX, IMM", description: "Move immediate", classBinary: "10 (non-branch)", classSpecOpcode: "010 ", operands: "REG(out) IMM", example: "MOVI R0, #10" },

  { instruction: "LSLI RZ, RX, IMM", description: "Logical shift left immediate", classBinary: "11", classSpecOpcode: "000", operands: "REG(out) REG(1) IMM", example: "LSLI R0, R1, #2" },
  { instruction: "LSRI RZ, RX, IMM", description: "Logical shift right immediate", classBinary: "11", classSpecOpcode: "001", operands: "REG(out) REG(1) IMM", example: "LSRI R0, R1, #2" },
  { instruction: "ASRI RZ, RX, IMM", description: "Arithmetic shift right immediate", classBinary: "11", classSpecOpcode: "010", operands: "REG(out) REG(1) IMM", example: "ASRI R0, R1, #2" },
  { instruction: "ASLI RZ, RX, IMM", description: "Arithmetic shift left immediate", classBinary: "11", classSpecOpcode: "011", operands: "REG(out) REG(1) IMM", example: "ASLI R0, R1, #2" },
  { instruction: "RORI RZ, RX, IMM", description: "Rotate right immediate", classBinary: "11", classSpecOpcode: "100", operands: "REG(out) REG(1) IMM", example: "RORI R0, R1, #2" },
];
export { isaData };